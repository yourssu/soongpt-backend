name: Docker - Build, Push to ECR and Deploy (Prod)

on:
  push:
    tags:
      - "release-*"
  workflow_dispatch:

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    environment: prod
    permissions:
      id-token: write
      contents: read

    defaults:
      run:
        working-directory: ./

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: us-east-1

      - name: Login to Amazon ECR Public
        id: login-ecr-public
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public
          registries: ${{ vars.ECR_PUBLIC_REGISTRY_ID }}

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Clean Build with Gradle (with Testing)
        run: |
          ./gradlew clean build

      - name: Build, tag, and push WAS image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-public.outputs.registry }}/${{ vars.ECR_PUBLIC_REGISTRY_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ECR_REGISTRY: $ECR_REGISTRY"
          echo "ECR_REPOSITORY: yourssu/${{ vars.PROJECT_NAME }}"
          echo "Full image path: $ECR_REGISTRY/yourssu/${{ vars.PROJECT_NAME }}:latest"

          # Create and use a new builder instance
          docker buildx create --use --name arm-builder

          # Build ARM64 image and push with cache
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --push \
            --provenance=false \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -t $ECR_REGISTRY/yourssu/${{ vars.PROJECT_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/yourssu/${{ vars.PROJECT_NAME }}:latest \
            .

      - name: Build, tag, and push rusaint-service image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-public.outputs.registry }}/${{ vars.ECR_PUBLIC_REGISTRY_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --push \
            --provenance=false \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -t $ECR_REGISTRY/yourssu/${{ vars.PROJECT_NAME }}/rusaint-service:$IMAGE_TAG \
            -t $ECR_REGISTRY/yourssu/${{ vars.PROJECT_NAME }}/rusaint-service:latest \
            -f rusaint_service/Dockerfile \
            rusaint_service/

      - name: Clean up old ECR Public images
        env:
          WAS_REPO: yourssu/${{ vars.PROJECT_NAME }}
          RUSAINT_REPO: yourssu/${{ vars.PROJECT_NAME }}/rusaint-service
          KEEP_COUNT: 5
        run: |
          for REPO in "$WAS_REPO" "$RUSAINT_REPO"; do
            echo "Cleaning up $REPO (keeping latest $KEEP_COUNT)..."
            IMAGE_DIGESTS=$(aws ecr-public describe-images \
              --region us-east-1 \
              --repository-name "$REPO" \
              --query "imageDetails | sort_by(@, &imagePushedAt) | reverse(@) | [$KEEP_COUNT:].imageDigest" \
              --output text 2>/dev/null) || continue

            if [ -n "$IMAGE_DIGESTS" ] && [ "$IMAGE_DIGESTS" != "None" ]; then
              IMAGE_IDS=$(echo "$IMAGE_DIGESTS" | tr '\t' '\n' | sed 's/^/imageDigest=/')
              aws ecr-public batch-delete-image \
                --region us-east-1 \
                --repository-name "$REPO" \
                --image-ids $IMAGE_IDS || true
              echo "Deleted old images from $REPO"
            else
              echo "No old images to clean up in $REPO"
            fi
          done

      - name: Deploy to EC2 (Blue/Green)
        env:
          # SSH
          YOURSSU_PEM: ${{ secrets.YOURSSU_PEM }}
          HOST_URL: ${{ vars.HOST_URL }}
          SSH_PORT: ${{ vars.SSH_PORT }}

          # App/Infra
          PROJECT_NAME: ${{ vars.PROJECT_NAME }}
          ENVIRONMENT: ${{ vars.ENVIRONMENT }}

          # Ports (BLUE is the existing SERVER_PORT; GREEN defaults to +1)
          BLUE_PORT: ${{ vars.SERVER_PORT }}

          CORS_ALLOWED_ORIGIN: ${{ vars.CORS_ALLOWED_ORIGIN }}

          DB_URL: ${{ secrets.DB_URL }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}

          SLACK_CHANNEL: ${{ vars.SLACK_CHANNEL }}
          SLACK_LOG_CHANNEL: ${{ vars.SLACK_LOG_CHANNEL }}
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}

          ECR_REGISTRY: ${{ steps.login-ecr-public.outputs.registry }}/${{ vars.ECR_PUBLIC_REGISTRY_ID }}

          RUSAINT_PSEUDONYM_SECRET: ${{ secrets.RUSAINT_PSEUDONYM_SECRET }}
          RUSAINT_INTERNAL_JWT_SECRET: ${{ secrets.RUSAINT_INTERNAL_JWT_SECRET }}

          SSO_FRONTEND_URL: ${{ vars.SSO_FRONTEND_URL }}
          SSO_CLIENT_JWT_SECRET: ${{ secrets.SSO_CLIENT_JWT_SECRET }}
          SSO_ALLOWED_REDIRECT_URLS: ${{ vars.SSO_ALLOWED_REDIRECT_URLS }}
          SSO_COOKIE_SAME_SITE: ${{ vars.SSO_COOKIE_SAME_SITE }}
          SSO_COOKIE_SECURE: ${{ vars.SSO_COOKIE_SECURE }}

          IMAGE_TAG: ${{ github.sha }}
          CLEANUP_OLD: true
        run: |
          set -euo pipefail

          SSH_PORT="${SSH_PORT:-22}"
          SSH_COMMON_OPTS="-o ServerAliveInterval=30 -o ServerAliveCountMax=10"

          GREEN_PORT="$((BLUE_PORT + 1))"

          BASE_DIR="/home/ubuntu/${PROJECT_NAME}-api"
          BLUE_DIR="${BASE_DIR}/blue"
          GREEN_DIR="${BASE_DIR}/green"

          echo "[INFO] BLUE_PORT=$BLUE_PORT, GREEN_PORT=$GREEN_PORT"
          echo "[INFO] Deploying IMAGE_TAG=$IMAGE_TAG"

          mkdir -p ~/.ssh
          ssh-keyscan -p "$SSH_PORT" -H "$HOST_URL" >> ~/.ssh/known_hosts
          echo "$YOURSSU_PEM" > yourssu.pem
          chmod 600 yourssu.pem

          echo "[1/4] Create remote directories"
          ssh $SSH_COMMON_OPTS -p "$SSH_PORT" -i yourssu.pem ubuntu@"$HOST_URL" \
            "mkdir -p '$BLUE_DIR/logs' '$GREEN_DIR/logs' '$BASE_DIR'"

          echo "[2/4] Generate env files (blue/green)"
          : > .env.blue
          : > .env.green

          # shared values
          for f in .env.blue .env.green; do
            echo "CORS_ALLOWED_ORIGIN=$CORS_ALLOWED_ORIGIN" >> "$f"
            echo "DB_URL=$DB_URL" >> "$f"
            echo "DB_USERNAME=$DB_USERNAME" >> "$f"
            echo "DB_PASSWORD=$DB_PASSWORD" >> "$f"
            echo "ADMIN_PASSWORD=$ADMIN_PASSWORD" >> "$f"
            echo "PROJECT_NAME=$PROJECT_NAME" >> "$f"
            echo "ENVIRONMENT=$ENVIRONMENT" >> "$f"
            echo "SLACK_CHANNEL=$SLACK_CHANNEL" >> "$f"
            echo "SLACK_LOG_CHANNEL=$SLACK_LOG_CHANNEL" >> "$f"
            echo "SLACK_TOKEN=$SLACK_TOKEN" >> "$f"
            echo "ECR_REGISTRY=$ECR_REGISTRY" >> "$f"
            echo "RUSAINT_BASE_URL=http://rusaint-service:8001" >> "$f"
            echo "RUSAINT_PSEUDONYM_SECRET=$RUSAINT_PSEUDONYM_SECRET" >> "$f"
            echo "RUSAINT_INTERNAL_JWT_SECRET=$RUSAINT_INTERNAL_JWT_SECRET" >> "$f"
            echo "SSO_FRONTEND_URL=$SSO_FRONTEND_URL" >> "$f"
            echo "SSO_CLIENT_JWT_SECRET=$SSO_CLIENT_JWT_SECRET" >> "$f"
            echo "SSO_ALLOWED_REDIRECT_URLS=${SSO_ALLOWED_REDIRECT_URLS:-}" >> "$f"
            echo "SSO_COOKIE_SAME_SITE=${SSO_COOKIE_SAME_SITE:-Lax}" >> "$f"
            echo "SSO_COOKIE_SECURE=${SSO_COOKIE_SECURE:-true}" >> "$f"
          done

          # per-color ports
          echo "SERVER_PORT=$BLUE_PORT" >> .env.blue
          echo "SERVER_PORT=$GREEN_PORT" >> .env.green

          echo "[3/4] Upload compose + env files"
          scp $SSH_COMMON_OPTS -P "$SSH_PORT" -i yourssu.pem docker-compose.deploy.yml ubuntu@"$HOST_URL":"$BLUE_DIR/"
          scp $SSH_COMMON_OPTS -P "$SSH_PORT" -i yourssu.pem docker-compose.deploy.yml ubuntu@"$HOST_URL":"$GREEN_DIR/"
          scp $SSH_COMMON_OPTS -P "$SSH_PORT" -i yourssu.pem .env.blue ubuntu@"$HOST_URL":"$BLUE_DIR/.env"
          scp $SSH_COMMON_OPTS -P "$SSH_PORT" -i yourssu.pem .env.green ubuntu@"$HOST_URL":"$GREEN_DIR/.env"

          echo "[4/4] Remote blue/green deploy + switch"
          CLEANUP_OLD="${CLEANUP_OLD:-true}"
          
          # We pass variables by exporting them in the remote shell command
          ssh $SSH_COMMON_OPTS -p "$SSH_PORT" -i yourssu.pem ubuntu@"$HOST_URL" \
            "export PROJECT_NAME='$PROJECT_NAME' BLUE_PORT='$BLUE_PORT' GREEN_PORT='$GREEN_PORT' IMAGE_TAG='$IMAGE_TAG' CLEANUP_OLD='$CLEANUP_OLD'; bash -s" << 'REMOTE'
          set -euo pipefail

          # Verify vars are present
          : "${PROJECT_NAME:?PROJECT_NAME is required}"
          : "${BLUE_PORT:?BLUE_PORT is required}"
          : "${GREEN_PORT:?GREEN_PORT is required}"
          : "${IMAGE_TAG:?IMAGE_TAG is required}"

          BASE_DIR="/home/ubuntu/${PROJECT_NAME}-api"
          BLUE_DIR="${BASE_DIR}/blue"
          GREEN_DIR="${BASE_DIR}/green"
          STATE_FILE="${BASE_DIR}/.active_color"

          NGINX_CONF="/etc/nginx/sites-available/soongpt"
          if [ ! -f "$NGINX_CONF" ]; then
            NGINX_CONF="/etc/nginx/sites-enabled/soongpt"
          fi

          if [ ! -f "$NGINX_CONF" ]; then
            echo "[ERROR] nginx config not found at /etc/nginx/sites-(available|enabled)/soongpt"
            exit 1
          fi

          ACTIVE_PORT=""
          if [ -f "$STATE_FILE" ]; then
            ACTIVE_COLOR="$(cat "$STATE_FILE" | tr -d ' \n\r\t' || true)"
            if [ "$ACTIVE_COLOR" = "blue" ]; then
              ACTIVE_PORT="$BLUE_PORT"
            elif [ "$ACTIVE_COLOR" = "green" ]; then
              ACTIVE_PORT="$GREEN_PORT"
            fi
          fi

          if [ -z "$ACTIVE_PORT" ]; then
            # Fallback: try to detect from nginx config
            ACTIVE_PORT="$(grep -hoE 'proxy_pass http://127\.0\.0\.1:[0-9]+' "$NGINX_CONF" | head -n 1 | sed -E 's/.*:([0-9]+)$/\1/' || true)"
          fi

          if [ -z "$ACTIVE_PORT" ]; then
            echo "[WARN] Could not detect active port; defaulting to BLUE_PORT=$BLUE_PORT"
            ACTIVE_PORT="$BLUE_PORT"
          fi

          if [ "$ACTIVE_PORT" = "$BLUE_PORT" ]; then
            TARGET_COLOR="green"
            TARGET_PORT="$GREEN_PORT"
            TARGET_DIR="$GREEN_DIR"
            OLD_COLOR="blue"
            OLD_DIR="$BLUE_DIR"
          else
            TARGET_COLOR="blue"
            TARGET_PORT="$BLUE_PORT"
            TARGET_DIR="$BLUE_DIR"
            OLD_COLOR="green"
            OLD_DIR="$GREEN_DIR"
          fi

          echo "[INFO] Active port: $ACTIVE_PORT ($OLD_COLOR)"
          echo "[INFO] Target port: $TARGET_PORT ($TARGET_COLOR)"
          echo "[INFO] Target dir:  $TARGET_DIR"

          echo "[1/5] Pull & start target stack"
          cd "$TARGET_DIR"
          # Explicitly set project name to avoid ambiguity
          TARGET_PROJECT="${PROJECT_NAME}-${TARGET_COLOR}"
          IMAGE_TAG="$IMAGE_TAG" docker compose -p "$TARGET_PROJECT" -f docker-compose.deploy.yml pull
          IMAGE_TAG="$IMAGE_TAG" docker compose -p "$TARGET_PROJECT" -f docker-compose.deploy.yml up -d

          echo "[2/5] Wait for health: http://127.0.0.1:${TARGET_PORT}/actuator/health"
          ok="false"
          for i in $(seq 1 30); do
            if curl -fsS "http://127.0.0.1:${TARGET_PORT}/actuator/health" | grep -q '"status"[[:space:]]*:[[:space:]]*"UP"'; then
              ok="true"
              break
            fi
            sleep 5
          done

          if [ "$ok" != "true" ]; then
            echo "[ERROR] Target did not become healthy in time"
            docker compose -p "$TARGET_PROJECT" -f docker-compose.deploy.yml ps || true
            docker compose -p "$TARGET_PROJECT" -f docker-compose.deploy.yml logs --tail 200 || true
            exit 1
          fi

          echo "[3/5] Switch nginx upstream to $TARGET_PORT (graceful reload)"
          # Escape dots in regex and handle whitespace
          sudo sed -i -E "s#proxy_pass[[:space:]]+http://127\.0\.0\.1:[0-9]+#proxy_pass http://127.0.0.1:${TARGET_PORT}#g" "$NGINX_CONF"
          
          # Validate and reload
          if sudo nginx -t; then
            sudo systemctl reload nginx
            echo "[DONE] Nginx reloaded with port $TARGET_PORT"
          else
            echo "[ERROR] Nginx config check failed. Reverting..."
            # Revert regex
             sudo sed -i -E "s#proxy_pass http://127\.0\.0\.1:[0-9]+#proxy_pass http://127.0.0.1:${ACTIVE_PORT}#g" "$NGINX_CONF"
             exit 1
          fi

          echo "[4/5] Persist active color"
          echo "$TARGET_COLOR" | sudo tee "$STATE_FILE" >/dev/null

          if [ "${CLEANUP_OLD:-true}" = "true" ]; then
            echo "[5/5] Stop old stack (best effort): $OLD_DIR"
            OLD_PROJECT="${PROJECT_NAME}-${OLD_COLOR}"
            if [ -d "$OLD_DIR" ] && [ -f "$OLD_DIR/docker-compose.deploy.yml" ]; then
              (cd "$OLD_DIR" && docker compose -p "$OLD_PROJECT" -f docker-compose.deploy.yml down) || true
            fi
            
            # Legacy dir cleanup (if applicable)
            LEGACY_DIR="$BASE_DIR"
            # Attempting to stop legacy containers if they exist without project name or with old naming
            # We skip this complex logic for now as we manually cleaned up.
          else
            echo "[INFO] CLEANUP_OLD=false (keeping old stack running)"
          fi

          echo "[DONE] Blue/green switch completed successfully"
          REMOTE
