# 교양필수 분야 매칭 흐름 & lateFields 오류 가능 원인

## 1. 분야 매칭이 되는 흐름

### 1) DB → 분야명 추출 (FieldFinder)

- **입력**: `course.field` (DB 컬럼, 여러 줄 가능), `schoolId` (= `basicInfo.year % 100`, 예: 23·24·25)
- **로직** (`FieldFinder.findFieldBySchoolId(field, schoolId)`):
  1. `field`를 `\n`으로 split → 한 줄마다 `[연도범위]분야명` 형태로 파싱
  2. 연도 범위 파싱 예:
     - `['23이후]` → 23..99
     - `['20~'22]` → 20..22
  3. **schoolId가 들어가는 줄**을 찾고, 그 줄의 **`]` 뒤 문자열 전체**를 분야명으로 사용
  4. `parseFieldName(line)`: **마지막 `]` 뒤**를 그대로 반환

```text
예: line = "교필-['23이후]품격(글로벌시민의식)"
     → 마지막 ] 뒤 = "품격(글로벌시민의식)"  (요구사항 분야명 "글로벌시민의식"이 아님)
예: line = "['23이후]SW와AI"
     → "SW와AI"
```

- 같은 “논리적 분야”라도 DB에 따라 **분야명 문자열이 다르게** 들어가 있으면, 서로 **다른 분야**로 그룹핑됨.

### 2) 분야별 그룹핑 (GeneralCourseRecommendService)

- `coursesByField`: 위에서 나온 **분야명 문자열**을 키로, 해당 분야 과목들을 그룹
- `fieldName`이 다르면 (예: `"품격(글로벌시민의식)"` vs `"글로벌시민의식"`) **서로 다른 키** → 같은 분야인데 두 그룹으로 쪼개질 수 있음

### 3) LATE 판정 → lateFields

- **미수강 분야만** 대상: 분야 안에 **이수한 과목이 하나도 없는** 분야만 `untakenFields`에 포함
- 각 분야에 대해:
  - `isFieldLate = courses.all { it.isLateFor(userGrade) }`
  - **그 분야의 모든 과목**이 `userGrade !in targetGrades` 이면 LATE
- LATE인 분야의 **분야명 문자열**이 그대로 `lateFields`에 추가

정리하면:

- **분야명** = FieldFinder가 **`]` 뒤를 그대로** 쓴 값 (DB 저장 형식에 따라 "품격(글로벌시민의식)" 등으로 나올 수 있음)
- **같은 분야가 DB 형식 차이로 두 키로 나뉘면** → lateFields에 비슷한 이름이 2개 들어갈 수 있음
- **targetGrades**가 잘못 들어가 있으면 (예: 2학년 과목인데 3 포함) → LATE/ON_TIME 판정이 뒤바뀜

---

## 2. lateFields가 “두 개 나왔는데 틀렸다”로 보일 수 있는 이유

### (1) DB `field` 형식 때문에 분야명이 두 가지로 나옴 (가장 유력)

- 요구사항/화면 기대: 분야당 하나의 이름 (예: `"글로벌시민의식"`)
- 실제 DB 예:
  - 일부 과목: `교필-['23이후]품격(글로벌시민의식)` → FieldFinder 결과 **"품격(글로벌시민의식)"**
  - 다른 과목: `['23이후]글로벌시민의식` → **"글로벌시민의식"**
- 그러면 **같은 논리적 분야가 두 그룹**으로 나뉘고, 둘 다 미수강이면 **lateFields에 두 개** 들어감.

### (2) 괄호 안만 쓰고 싶은데 앞에 접두어가 붙음

- `parseFieldName`은 **마지막 `]` 뒤 전체**를 쓰므로:
  - `['23이후]창의(비판적사고와표현)` → **"창의(비판적사고와표현)"**
  - 원하는 건 **"비판적사고와표현"**일 수 있음
- 그래서 “분야명이 틀렸다”고 느낄 수 있음.

### (3) LATE/ON_TIME 판정이 잘못됨

- LATE는 **해당 분야의 모든 과목**이 `userGrade !in targetGrades`일 때만 적용
- Target 테이블의 `grade1~5`가 잘못 들어가 있으면 (예: 3학년 대상인데 3이 빠짐) 그 분야가 잘못 LATE로 잡힐 수 있음
- 반대로, “전체학년”으로 들어가 있으면 (`targetGrades = [1,2,3,4,5]`) 그 분야는 항상 ON_TIME이 되어 LATE로 안 나옴

### (4) schoolId가 잘못되면 다른 줄이 선택됨

- `schoolId = basicInfo.year % 100` (입학년도 기준이면 23학번→23, 24학번→24)
- 여기서 쓰는 `year`가 “입학년도”가 아니라 “현재 학년도” 등이면, `['23이후]` / `['20~'22]` 선택이 바뀌어 **다른 분야명**이 나올 수 있음

---

## 3. 확인하면 좋은 것들

1. **실제 DB의 교양필수 `field` 값**
   - 같은 “분야”인데 서로 다른 문자열로 저장돼 있는지 (예: `품격(글로벌시민의식)` vs `글로벌시민의식`)
2. **현재 사용자 기준 `schoolId`**
   - `basicInfo.year % 100`이 23/24/25 중 무엇으로 나오는지
3. **LATE로 나온 분야의 과목들 `target` / target 테이블**
   - 해당 분야 과목이 “몇 학년 대상”인지, `grade1~5`가 그에 맞게 들어가 있는지
4. **FieldFinder 결과**
   - 문제 되는 과목들의 `course.field`에 대해 `FieldFinder.findFieldBySchoolId(field, schoolId)`를 호출했을 때 어떤 분야명이 나오는지

---

## 4. 수정 방향 제안

- **분야명 통일**
  - DB에 `]` 뒤 분야명을 **요구사항과 동일한 한 가지 문자열**만 쓰도록 정리하거나,
  - FieldFinder에서 `]` 뒤가 `"품격(글로벌시민의식)"` 형태일 때 **괄호 안만** 쓰도록 정규화 (예: `(글로벌시민의식)` → `글로벌시민의식`) 하면, 같은 분야가 한 키로 묶이고 lateFields도 하나로 나올 수 있음.
- **LATE 판정**
  - Target 데이터가 학년별 대상과 일치하는지 점검하면, “이 분야는 LATE가 맞는데/아닌데 두 개 나온다” 같은 혼란을 줄일 수 있음.

원하시면 FieldFinder에 `(xxx)` 괄호 안만 추출하는 옵션이나, 교양필수 전용 분야명 정규화 로직을 넣는 코드 예시도 적어 드리겠습니다.
